<!DOCTYPE HTML>
<!--
	Theory by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
--><html><head><title>Elements - Theory by TEMPLATED</title><meta charset="utf-8"><meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="assets/css/main.css"><link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon"></head><body class="subpage">

		<!-- Header -->
			<header id="header"><div class="inner">
					<a href="index.html" class="logo" style="font-size: 30px;">От 0 до Assembler</a>
					<nav id="nav"><a href="index.html" style="font-size: 20px;">Главная</a>
						<a href="SystemProgramming.html" style="font-size: 20px;">Системное программирование</a>
						<a href="Assembler.html" style="font-size: 20px;">Assembler</a>
					</nav><a href="#navPanel" class="navPanelToggle"><span class="fa fa-bars"></span></a>
				</div>
			</header><!-- Main --><section id="main" class="wrapper"><div class="inner">
					<header class="align-center"><h2 style="font-size: 60px;">Assembler</h2>
						<p style="font-size: 20px;">В этом разделе вы погрузитесь в мир языка Assembler, изучите основы работы с ним и научитесь создавать простые программы, взаимодействующие с низкоуровневыми ресурсами компьютера. </p>
					</header>
					<!-- Content -->
					<h1 style="font-size: 30px;">Содержание:</h1>
					<ul>
					<li><a href="#p1">1. Введение</a></li>
					<li><a href="#p2">2. Основные концепции</a></li>
					<li><a href="#p3">3. Практика</a></li>
					<li><a href="#p4">4. Дополнительные материалы</a></li>
					<li><a href="#p5">Тест</a></li>
					</ul>

					<h1 style="font-size: 30px;" id="p1">1. Введение</h1>
					<h3 id="p1.1">1.1. Что такое Assembler?</h3>
						<p>Assembler - это язык программирования низкого уровня, работающий непосредственно с инструкциями процессора. В отличие от языков высокого уровня, таких как C++ или Python, Assembler не требует компиляции в промежуточный код перед выполнением. Программы на Assembler’е представляют собой последовательность инструкций, которые процессор может выполнить напрямую.</p>
					<h3 id="p1.2">1.2. Как работает Assembler?</h3>
						<p>Процесс работы с Assembler’ом выглядит следующим образом:</p>
						<ol>
							<li><b>Написание кода: </b>Программист пишет код на языке Assembler, используя набор инструкций, специфичных для конкретной архитектуры процессора.</li>
							<li><b>Сборка: </b>Код на Assembler’е обрабатывается специальной программой - ассемблером. Ассемблер преобразует код на Assembler’е в машинный код - последовательность двоичных инструкций, которые процессор может выполнить.</li>
							<li><b>Выполнение: </b>Машинный код загружается в память и выполняется процессором.</li>
						</ol>
					<h3 id="p1.3">1.3. Зачем изучать Assembler?</h3>
						<p>Изучение Assembler’а дает вам ряд преимуществ:</p>
							<ul class="alt">
								<li><strong>Максимальная оптимизация скорости выполнения: </strong>Assembler позволяет создавать программы, работающие максимально быстро, так как программист имеет полный контроль над инструкциями, выполняемыми процессором.</li>
								<li><strong>Прямой доступ к аппаратным ресурсам: </strong>Assembler дает возможность напрямую работать с памятью, регистрами процессора, устройствами ввода-вывода и другими низкоуровневыми ресурсами компьютера.</li>
								<li><strong>Глубокое понимание архитектуры процессора: </strong>Изучая Assembler, вы познаете внутреннее устройство процессора, изучите, как он выполняет инструкции, взаимодействует с памятью и управляет ресурсами.</li>
								<li><strong>Возможность создания эффективных драйверов и встраиваемых систем: </strong>Assembler используется для разработки критически важного программного обеспечения, такого как драйверы устройств, встраиваемые системы, операционные системы, где важна высокая производительность и прямой доступ к аппаратным ресурсам.</li>
							</ul>
					<h3 id="p1.4">1.4. Различия между Assembler’ом для разных архитектур:</h3>
						<p>Современные компьютеры используют различные архитектуры процессоров, каждая из которых имеет свой собственный набор инструкций и особенности:</p>
							<ul>
								<li><strong>x86: </strong>Наиболее распространенная архитектура, используемая в персональных компьютерах (PC).</li>
								<li><strong>ARM: </strong>Архитектура, используемая в мобильных устройствах, встраиваемых системах и некоторых серверах.</li>
								<li><strong>RISC-V: </strong> Новая открытая архитектура процессоров, стремящаяся стать стандартом в будущем.</li>
							</ul>
						<p>Assembler для каждой архитектуры имеет свой собственный синтаксис, набор инструкций и регистров процессора. Например, инструкция mov для перемещения данных в регистр в Assembler’е для x86 будет отличаться от инструкции mov в Assembler’е для ARM.</p>
					<h1 style="font-size: 30px;" id="p2">2. Основные концепции:</h1>
					<h3 id="p2.1">2.1. Регистры процессора:</h3>
						<p>Регистры процессора - это маленькие, быстродействующие хранилища данных, используемые процессором во время выполнения программ. Они позволяют быстро и эффективно обрабатывать данные и управлять выполнением программы.</p>
						<h3>Типы регистров:</h3>
						<ol>
							<li><strong>Регистры общего назначения (General Purpose Registers): </strong>Используются для хранения данных, которые используются в вычислениях и операциях с данными. Например, <span style="color: red;"><code>eax</code></span>, <span style="color: red;"><code>ebx</code></span>, <span style="color: red;"><code>ecx</code></span>, <span style="color: red;"><code>edx</code></span> в x86 Assembler’е.</li>
							<li><strong>Регистр стека (Stack Pointer): </strong>Указывает на текущую позицию в стеке - структуре данных “последним зашел, первым выйдет”, используемой для хранения временных данных и адресов возврата при вызове процедур.</li>
							<li><strong>Регистр флагов (Flags Register): </strong>Хранит биты, отражающие результат выполнения инструкций. Например, флаг переноса (<span style="color: red;"><code>carry flag</code></span>) указывает на перенос из старшего разряда при сложении чисел</li>
							<li><strong>Регистр указателя инструкций (Instruction Pointer): </strong>Хранит адрес следующей инструкции, которую должен выполнить процессор.</li>
						</ol>
						<h3>Пример использования регистров в коде на Assembler’е (x86):</h3>
						<pre><code>
	mov eax, 10     ; Перемещение значения 10 в регистр eax
	add eax, 5      ; Сложение значения 5 к содержимому регистра eax
	mov [0x1000], eax ; Сохранение значения регистра eax в ячейку памяти по адресу 0x1000
						</pre></code>
						<h3 id="p2.2">2.2. Инструкции процессора:</h3>
						<p>Инструкции процессора - это базовые команды, которые процессор может выполнять. Каждая инструкция выполняет определенное действие над данными, например, сложение двух чисел, перемещение данных из памяти в регистр, сравнение двух значений.</p>	
						<h3>Типы инструкций:</h3>
						<ol>
							<li><strong>Арифметические инструкции:</strong> Выполняют арифметические операции над данными, например, сложение, вычитание, умножение, деление.</li>
							<li><strong>Логические инструкции:</strong> Выполняют логические операции над данными, например, И, ИЛИ, НЕ, XOR.</li>
							<li><strong>Инструкции переноса данных:</strong> Перемещают данные между регистрами, памятью и устройствами ввода-вывода.</li>
							<li><strong>Инструкции управления потоком выполнения:</strong> Управляют последовательностью выполнения инструкций, например, условные переходы, циклы, вызовы процедур.</li>
						</ol>
						<h3>Синтаксис записи инструкций на Assembler’е (x86):</h3>
						<pre><code>
	mov eax, 10   ; Перемещение значения 10 в регистр eax
	add eax, 5    ; Сложение значения 5 к содержимому регистра eax
	jmp 0x1000  ; Безусловный переход по адресу 0x1000
						</code></pre>
						<h3 id="p2.3">2.3. Адресация памяти:</h3>
						<p>Адресация памяти - это способ обращения к конкретным ячейкам памяти из кода на Assembler’е. Различные способы адресации позволяют обращаться к разным частям памяти и использовать ее эффективно.</p>
						<h3>Типы адресации:</h3>
						<ol>
							<li><strong>Непосредственная адресация:</strong> Используется для прямого обращения к конкретной ячейке памяти по ее адресу.</li>
							<li><strong>Регистровая адресация:</strong> Используется для обращения к ячейке памяти, адрес которой хранится в регистре.</li>
							<li><strong>Относительная адресация:</strong> Используется для обращения к ячейке памяти, относительно текущего адреса инструкции или регистра.</li>
						</ol>
						<h3>Пример использования разных способов адресации в коде на Assembler’е (x86):</h3>
						<pre><code>
	mov [0x1000], eax  ; Непосредственная адресация - запись значения регистра eax в ячейку памяти по адресу 0x1000
	mov [ebx], eax     ; Регистровая адресация - запись значения регистра eax в ячейку памяти по адресу, хранящемуся в регистре ebx
	mov [ebp+4], eax   ; Относительная адресация - запись значения регистра eax в ячейку памяти по адресу, расположенному на 4 байта выше значения регистра ebp
						</code></pre>
						<h3 id="p2.4">2.4. Структуры данных:</h3>
						<p>Структуры данных - это способы организации данных в памяти для более эффективного использования и обработки.</p>
						<h3>Основные структуры данных в Assembler’е:</h3>
						<ol>
							<li><strong>Массивы:</strong> Последовательность элементов одного типа данных, хранящихся в смежных ячейках памяти.</li>
							<li><strong>Стек:</strong> Структура данных “последним зашел, первым выйдет”, используемая для хранения временных данных, адресов возврата при вызове процедур.</li>
							<li><strong>Очереди:</strong> Структура данных “первым зашел, первым выйдет”, используемая для хранения и обработки данных в порядке их поступления.</li>
						</ol>
						<h3>Пример реализации структур данных в коде на Assembler’е (x86):</h3>
						<pre><code>
	; Массив из 10 целых чисел 
	mov ecx, 10     ; Задаем количество элементов массива
	mov ebx, 0x1000 ; Задаем адрес начала массива в памяти
							
	; Заполнение массива значениями 
	mov esi, 0      ; Инициализируем индекс массива
	loop_fill:
		mov [ebx + esi * 4], esi ; Записываем значение индекса в элемент массива
		inc esi          ; Увеличиваем индекс
		cmp esi, ecx    ; Сравниваем индекс с количеством элементов
		jl loop_fill   ; Продолжаем цикл, если индекс меньше количества элементов
							
	; Стек
	push eax        ; Добавляем значение регистра eax в стек
	push ebx        ; Добавляем значение регистра ebx в стек
	pop ebx         ; Извлекаем значение из стека и помещаем в регистр ebx
	pop eax         ; Извлекаем значение из стека и помещаем в регистр eax
							
	; Очередь (простая реализация)
	mov ecx, 0x1000 ; Адрес начала очереди в памяти
	mov esi, 0       ; Индекс головного элемента очереди
	mov edi, 0       ; Индекс хвостового элемента очереди
							
	; Добавление элемента в очередь 
	push 5           ; Добавляем значение 5 в стек
	pop [ecx + edi * 4]  ; Перемещаем значение из стека в очередь
	inc edi        ; Увеличиваем индекс хвостового элемента
							
	; Извлечение элемента из очереди
	mov eax, [ecx + esi * 4] ; Перемещаем значение из очереди в регистр eax
	inc esi         ; Увеличиваем индекс головного элемента	
						</code></pre>


					<h1 style="font-size: 30px;" id="p3">3. Практика:</h1>
					<h3 style="font-size: 27px;" id="p3.1">3.1. Простые программы на Assembler:</h3>
					<h3 id="p3.1.1">3.1.1. “Hello World!” на Assembler’е:</h3>
					<pre><code>
	.model small  ; Модель памяти - компактная
	.stack 100h   ; Размер стека - 100 байт

	.data
		message db 'Hello, World!', 13, 10, '$' ; Строка "Hello, World!" с символами перевода строки и конца строки

	.code
	main proc far
		mov ax, @data ; Загрузка сегмента данных в регистр ax
		mov ds, ax     ; Установка сегмента данных

		; Вывод сообщения на экран 
		mov ah, 09h      ; Функция вывода строки
		lea dx, message  ; Загрузка адреса сообщения в регистр dx
		int 21h        ; Прерывание для вывода на экран

		; Завершение программы
		mov ah, 4ch       ; Функция завершения программы
		int 21h         ; Прерывание для завершения программы

	main endp
	end main
					</code></pre>
					<h3>Пояснение:</h3>
					<div class="description">
					<ol>
						<li><code>.model small</code>: Определяет модель памяти как компактную (все данные и код хранятся в одном сегменте).</li>
						<li><code>.stack 100h</code>: Задает размер стека - временного хранилища данных - в 100 байт.</li>
						<li><code>.data</code>: Раздел для объявления переменных (в данном случае строка <code>message</code>).</li>
						<li><code>.code</code>: Раздел для кода программы.</li>
						<li><code>main proc far</code>: Определение процедуры <code>main</code> - точки входа в программу.</li>
						<li><code>mov ax, @data</code>: Загрузка адреса сегмента данных в регистр <code>ax</code>.</li>
						<li><code>mov ds, ax</code>: Установка сегмента данных с помощью значения в регистре <code>ax</code>.</li>
						<li><code>mov ah, 09h</code>: Загрузка кода функции вывода строки в регистр <code>ah</code>.</li>
						<li><code>lea dx, message</code>: Загрузка адреса переменной <code>message</code> в регистр <code>dx</code>.</li>
						<li><code>int 21h</code>: Вызов прерывания DOS для вывода строки на экран.</li>
						<li><code>mov ah, 4ch</code>: Загрузка кода функции завершения программы в регистр <code>ah</code>.</li>
						<li><code>int 21h</code>: Вызов прерывания DOS для завершения программы.</li>
					</ol>
					</div>
					<h3 id="p3.1.2">3.1.2. Вычисления на Assembler’е:</h3>
					<pre><code>
	.model small
	.stack 100h

	.data
		num1 dw 10
		num2 dw 5
		result dw ? ; Переменная для результата

	.code
	main proc far
		mov ax, @data
		mov ds, ax

		; Загрузка операндов в регистры 
		mov ax, num1
		mov bx, num2

		; Выполнение операции сложения
		add ax, bx
		mov result, ax  ; Сохранение результата в переменную result

		; Вывод результата на экран
		; ... (используйте функцию вывода из предыдущего примера)

		mov ah, 4ch 
		int 21h

	main endp
	end main
					</code></pre>
					<h3>Пояснение:</h3>
					<div class="description">
					<ol>
						<li>В разделе <code>.data</code> объявлены две переменные <code>num1</code> и <code>num2</code> с значениями 10 и 5 соответственно.</li>
						<li>Переменная <code>result</code> объявлена с типом <code>dw</code> (word) и значением <code>?</code> (неизвестное), чтобы сохранить результат вычисления.</li>
						<li>В процедуре <code>main</code> значения переменных <code>num1</code> и <code>num2</code> загружаются в регистры <code>ax</code> и <code>bx</code>.</li>
						<li>Используется инструкция <code>add</code> для выполнения операции сложения (значение в регистре <code>bx</code> складывается к значению в регистре <code>ax</code> , результат записывается в регистр <code>ax</code>).</li>
						<li>Результат вычисления сохраняется в переменную <code>result</code>.</li>
					</ol>
					</div>
					<h3 id="3.1.3">3.1.3. Работа с памятью на Assembler’е:</h3>
					<pre><code>
	.model small
	.stack 100h

	.data
		array dw 10, 20, 30, 40, 50  ; Массив из 5 целых чисел
		index dw 2                 ; Индекс элемента массива

	.code
	main proc far
		mov ax, @data
		mov ds, ax

		; Чтение элемента массива по индексу
		mov bx, index             ; Загрузка индекса в регистр bx
		mov ax, [array + bx * 2]  ; Чтение значения элемента массива по индексу

		; Вывод значения на экран
		; ... (используйте функцию вывода из предыдущего примера)

		mov ah, 4ch
		int 21h

	main endp
	end main
					</code></pre>
					<h3>Пояснение:</h3>
					<div class="description">
						<ol>
							<li>В разделе <code>.data</code> объявлен массив <code>array</code> из пяти целых чисел и переменная <code>index</code> с значением 2.</li>
							<li>В процедуре <code>main</code> индекс загружается в регистр <code>bx</code></li>
							<li>Используется адресация памяти для чтения значения элемента массива по индексу: <code>[array + bx * 2]</code> - это адрес элемента массива, расположенного на <code>bx</code> позиций от начала массива.</li>
							<li>Значение элемента массива загружается в регистр <code>ax</code>.</li>
						</ol>
					</div>
					<h3 style="font-size: 27px;" id="p3.2">3.2. Более сложные примеры:</h3>
					<h3 id="p3.2.1">3.2.1. Управление прерываниями на Assembler’е:</h3>
					<p>Прерывания - это механизм, который позволяет обработать события, происходящие в системе, например, нажатие клавиши, приход данных по сети или ошибку в работе железа. Управление прерываниями - это сложный процесс, требующий глубокого понимания архитектуры процессора и операционной системы.</p>
					<h3>Пример управления прерыванием ввода с клавиатуры в DOS (x86):</h3>
					<pre><code>
	.model small
	.stack 100h

	.data
		message db 'Нажатая клавиша: $'

	.code
	main proc far
		mov ax, @data
		mov ds, ax

		; Установка обработчика прерывания клавиатуры
		mov ah, 35h
		lea dx, interrupt_handler
		int 21h

		; Ожидание нажатия клавиши
		mov ah, 00h
		int 16h

		; Вывод сообщения 
		mov ah, 09h
		lea dx, message
		int 21h

		; Вывод кода нажатой клавиши 
		mov ah, 02h
		mov dl, al        ; Перемещение кода клавиши в регистр dl 
		int 21h

		; Завершение программы 
		mov ah, 4ch
		int 21h

	main endp

	interrupt_handler proc near
		; Код обработчика прерывания
		; Например, сохранение кода клавиши в переменную
		mov ah, 00h
		int 16h
		mov [код_клавиши], al
		; Возврат в основную программу
		iret
	interrupt_handler endp

	.data
		код_клавиши db ?
	end main

					</code></pre>
					<h3>Описание:</h3>
					<div class="description">
					<h1 style="font-size: 20px;"><b>1. Установка обработчика прерывания:</b></h1>
					<ul>
						<li><code>mov ah, 35h</code>: Загрузка кода функции установки обработчика прерывания в регистр <code>ah</code>.</li>
						<li><code>lea dx, interrupt_handler</code>: Загрузка адреса обработчика прерывания в регистр <code>dx</code>.</li>
						<li><code>int 21h</code>: Вызов прерывания DOS для установки обработчика прерывания.
						</li>
					</ul>
					<h1 style="font-size: 20px;"><b>2. Ожидание нажатия клавиши:</b></h1>
					<ul>
						<li><code>mov ah, 00h</code>: Загрузка кода функции ожидания нажатия клавиши в регистр <code>ah</code>.</li>
						<li><code>int 16h</code>: Вызов прерывания BIOS для ожидания нажатия клавиши.</li>
					</ul>
					<h1 style="font-size: 20px;"><b>3. Обработчик прерывания(<code>interrupt_handler</code>):</b></h1>
					<ul>
						<li><code>mov ah, 00h</code>: Загрузка кода функции чтения кода клавиши в регистр <code>ah</code>.</li>
						<li><code>int 16h</code>: Вызов прерывания BIOS для чтения кода клавиши.</li>
						<li><code>mov [код_клавиши], al</code>: Сохранение кода клавиши в переменную.</li>
						<li><code>iret</code>: Возврат в основную программу.</li>
					</ul>
					</div>
					<h3 id="p3.2.2">3.2.2. Работа с устройствами ввода-вывода на Assembler’е:</h3>
					<p>Работа с устройствами ввода-вывода (например, с клавиатурой, мышью, диском) на Assembler’е требует использования специальных инструкций и режимов работы с устройствами. Необходимо учитывать специфику каждого устройства и использовать соответствующие функции и команды для взаимодействия с ним.</p>
					<h3>Пример работы с клавиатурой (чтение символа):</h3>
					<pre><code>
	.model small
	.stack 100h

	.data
		message db 'Введите символ: $'
		symbol db ?

	.code
	main proc far
		mov ax, @data
		mov ds, ax

		; Вывод сообщения 
		mov ah, 09h
		lea dx, message
		int 21h

		; Чтение символа 
		mov ah, 01h   
		int 21h       
		mov symbol, al ; Сохранение введенного символа

		; Вывод введенного символа
		mov ah, 02h
		mov dl, symbol
		int 21h

		mov ah, 4ch
		int 21h

	main endp
	end main

					</code></pre>
					<h3>Описание:</h3>
					<div class="description">
						<h1 style="font-size: 20px;"><b>1. Вывод сообщения:</b></h1>
						<ul>
							<li><code>mov ah, 09h</code>: Загрузка кода функции вывода строки в регистр <code>ah</code>.</li>
							<li><code>lea dx, message</code>: Загрузка адреса сообщения в регистр <code>dx</code>.</li>
							<li><code>int 21h</code>: Вызов прерывания DOS для вывода строки на экран.</li>
						</ul>
						<h1 style="font-size: 20px;"><b>2. Чтение символа:</b></h1>
						<ul>
							<li><code>mov ah, 01h</code>: Загрузка кода функции чтения символа с клавиатуры в регистр <code>ah</code>.</li>
							<li><code>int 21h</code>: Вызов прерывания DOS для чтения символа.</li>
							<li><code>mov symbol, al</code>: Сохранение введенного символа в переменную <code>symbol</code>.</li>
						</ul>
						<h1 style="font-size: 20px;"><b>3. Вывод введенного символа:</b></h1>
						<ul>
							<li><code>mov ah, 02h</code>: Загрузка кода функции вывода символа на экран в регистр <code>ah</code>.</li>
							<li><code>mov dl, symbol</code>: Загрузка введенного символа в регистр <code>dl</code>.</li>
							<li><code>int 21h</code>: Вызов прерывания DOS для вывода символа на экран.</li>
						</ul>
					</div>
					<h3 style="font-size: 27px;" id="p3.3">3.3. Дебаггинг кода на Assembler’е:</h3>
					<p>Отладка программ на Assembler’е может быть более сложной по сравнению с отладкой программ на языках высокого уровня. Это связано с тем, что Assembler работает непосредственно с инструкциями процессора, и отладчики должны предоставлять возможность изучать и изменять содержимое регистров, памяти и стека в режиме выполнения программы.</p>
					<h3>Инструменты отладки:</h3>
					<ul class="alt">
						<li><b>Отладчики (Debuggers):</b> Специализированные программы, позволяющие шагать по коду построчно, изучать содержимое регистров и памяти, устанавливать точки прерывания и анализировать причины ошибок. Примеры отладчиков: <a href="https://www.onlinegdb.com/online_gcc_assembler">gdb</a>, <a href="https://learn.microsoft.com/ru-ru/visualstudio/debugger/debugger-feature-tour?view=vs-2022">debugger for Visual Studio</a>.</li>
						<li><b>Симуляторы (Simulators):</b> Программы, имитирующие работу процессора и других компонентов компьютера. Они позволяют выполнять код на Assembler’е в виртуальной среде и изучать его поведение без необходимости запуска программы на реальном железе.</li>
					</ul>
					<h3>Методы отладки:</h3>
					<ul>
						<li><b>Проверка регистров:</b> Изучение содержимого регистров процессора в разные моменты выполнения программы для определения правильности выполнения инструкций.</li>
						<li><b>Проверка памяти:</b> Проверка значений в ячейках памяти, используемых программой, для определения правильности работы с данными.</li>
						<li><b>Точки прерывания (Breakpoints):</b> Установка точек прерывания в коде для остановки выполнения программы в определенных местах и изучения состояния программы в этот момент.</li>
					</ul>
					<h3>Важно:</h3>
					<ul class="alt">
						<li>Понимание основ работы отладчиков и методов отладки - ключ к успешной разработке программ на Assembler’е.</li>
						<li>Изучение отладчиков и методов отладки занимает отдельное время и требует практических упражнений.</li>
					</ul>
					<h1 style="font-size: 30px;" id="p4">4. Дополнительные материалы:</h1>
					<h3>4.1. Ссылки на документацию по Assembler’у для конкретных архитектур:</h3>
					<img src="images/Intel_logo.png" height="100px" width="200px">
					<p><a href="https://software.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-1-manual.pdf" target="_blank">Intel 64 and IA-32 Architectures Software Developer’s Manual</a> - официальный руководство по архитектуре x86 от Intel.</p>
					<img src="images/AMD_logo.png" height="100px" width="185px">
					<p><a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24592.pdf" target="_blank">AMD64 Architecture Programmer’s Manual</a> - официальный руководство по архитектуре x86-64 от AMD.</p>
					<img src="images/ARM_Logo.png" height="55px" width="200px">
					<p><a href="https://repository.root-me.org/Exploitation%20-%20Système/Unix/EN%20-%20ARM%20Architecture%20Reference%20Manual.pdf" target="_blank">ARM Architecture Reference Manual</a> - официальный руководство по архитектуре ARM от ARM.</p>
					<h3>4.2. Ресурсы для изучения Assembler’а на русском языке:</h3>
					<h3>Книги:</h3>
					<ul class="alt">
						<li>1. <a href="https://t.me/progbook/363" target="_blank">Ассемблер для процессоров Intel Pentium – Ю. Магда</a> Книга поможет овладеть базовыми знаниями по языку ассемблер. Автор разобрал широкий сегмент вопросов на простом и понятном языке. Не обращай внимания на процессор – основная суть программирования под Intel не поменялась, да и понимать инфу лучше на простых вещах. Каждый кусок текста усилен кодом, так что скучно не будет. Подойдет как для опытных программистов, так и для совсем “зеленых”.</li>
						<li>2. <a href="https://t.me/progbook/253" target="_blank">Assembler на примерах. Базовый курс – Р. Марек</a> Это издание – одно из лучших для новичков. Присутствует гора примеров с кодом, которые прекрасно задокументированы. После прочтения ты узнаешь, как программировать под разными ОС, как запустить пример на ассемблере, резидентные программы и многое другое. Отлично подойдет для новичков и студентов.</li>
						<li>3. <a href="https://t.me/progbook/3116" target="_blank">Программирование, введение в профессию. Низкоуровневое программирование – А. В. Столяров</a> В книге все начинается по закону жанра – история ВТ, математика, алгоритмы, вычислительные системы и прочее (про алгоритмизацию и выч.системы почитай отдельно – пригодится). Автор книги плавно тебя подводит к изучению языка С, поэтому указатели, память и рекурсия рассматриваются довольно часто. А еще ты узнаешь об отладке и о том, как правильно тестировать свой код.</li>
					</ul>
					<h3>Онлайн-курсы и учебные платформы:</h3>
					<ol>
						<li><b>Яндекс.Практикум:</b> <a href="https://practicum.yandex.ru/catalog/programming/" target="_blank">Курсы по программированию</a> - раздел с курсами по программированию, включая Assembler.</li>
						<li><b>Хабр:</b> <a href="https://habr.com/ru/search/?q=Assembler&target_type=posts&order=relevance" target="_blank">Статьи по ассемблеру</a> - раздел с статьями по Ассемблеру на Хабре.</li>
						<li><b>Youtube:</b> <a href="https://www.youtube.com/results?search_query=%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80+%D1%83%D1%80%D0%BE%D0%BA%D0%B8" target="_blank">Видеоуроки по ассемблеру</a> - много видеоуроков по Assembler’у на русском языке.</li>
					</ol>
					<h3>4.3. Примеры кода на Assembler’е с разъяснениями:</h3>
					<ul>
						<li><b>GitHub:</b> Используйте поиск по ключевым словам “Ассемблер примеры” или “assembly language examples” на GitHub для поиска примеров кода с разъяснениями.</li>
						<li><b>Stack Overflow:</b> Используйте поиск по ключевым словам “ассемблер примеры” на Stack Overflow для поиска примеров кода с объяснениями и решениями задач.</li>
						<li><b>Assembler Programming Tutorials:</b> Используйте поиск по ключевым словам “assembler programming tutorials russian” в поисковиках для поиска онлайн-учебников с примерами кода и разъяснениями.</li>
					</ul>
					<h1 style="font-size: 30px;">Помните:</h1>
					<p>Изучение Assembler’а - это процесс постоянного обучения и поиска новых знаний поэтому используйте документацию, учебники, онлайн-курсы и примеры кода для развития своих навыков и понимания Assembler’а.</p>
					<h2 style="font-size: 30px;" id="p5">Тест:</h2>
					<p>Вы готовы проверить свои знания? тогда вам пора пройти этот небольшой <a href="https://forms.gle/mXBdJpdNu84hYEPX8" target="_blank">тест</a> составленный по программе</p>
				</div>
				<footer id="footer"><div class="inner">
				</div>
			</footer><div class="copyright">
			Ссылка на автора: <a href="https://vk.com/nahigy">VK.COM</a>
		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script><script src="assets/js/skel.min.js"></script><script src="assets/js/util.js"></script><script src="assets/js/main.js"></script></body></html>
